---
title: "WNN CITE seq & 10x Multiome"
author: "Neal Liu"
date: "2024-02-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries & our own helper functions

```{r}


# devtools::install_version("Seurat")
library(Seurat)
# devtools::install_github('satijalab/seurat-data')
library(SeuratData)
library(cowplot)
library(dplyr)
library(ggplot2)
library(devtools)
library(umap)
library(ggridges)
library(viridis)
library(mclust)
library(edgeR)
library(Rfast)

# load our helper functions from github
devtools::source_url('https://raw.githubusercontent.com/Neal-Liu1/Multi-omics-integration/main/Helper_functions.R')

set.seed(42)

# devtools::install_github("sqjin/scAI")
# library(scAI)
# devtools::install_github("linnykos/tiltedCCA")
library(tiltedCCA)
# BiocManager::install("MOFA2")
library(MOFA2)

# remotes::install_github("yezhengSTAT/ADTnorm")
library(ADTnorm)

# install.packages('dsb')
library(dsb)
library(scran)
library(harmony)

# Load fastRUVIII
source('~/Edited_HelperFunctions_scMultiOmics_SuperFastRUVIIIPrPs.R')
# source('~/HelperFunctions_scMultiOmics_SuperFastRUVIIIPrPs.R')

# install.packages('rliger')
library(rliger)
# BiocManager::install("batchelor")
library(batchelor)

# rerun this later
# remotes::install_github('satijalab/seurat-wrappers')
library(SeuratWrappers)

```


Get the bone marrow CITEseq data from seurat on the VAST scratch on the HPC

```{r}
# SeuratData::InstallData("bmcite", destdir = '/vast/scratch/users/liu.ne')
bm_data <- LoadData(ds = "bmcite")

```


```{r}
DefaultAssay(bm_data) <- 'RNA'
bm_data <- NormalizeData(bm_data) %>% FindVariableFeatures() %>% ScaleData() %>% RunPCA()
```


```{r}
DefaultAssay(bm_data) <- 'ADT'
# we will use all ADT features for dimensional reduction
# we set a dimensional reduction name to avoid overwriting the 
VariableFeatures(bm_data) <- rownames(bm_data[["ADT"]])
bm_data <- NormalizeData(bm_data, normalization.method = 'CLR', margin = 2) %>% 
  ScaleData() %>% RunPCA(reduction.name = 'apca')

```

```{r}
# Identify multimodal neighbors. These will be stored in the neighbors slot, 
# and can be accessed using bm[['weighted.nn']]
# The WNN graph can be accessed at bm[["wknn"]], 
# and the SNN graph used for clustering at bm[["wsnn"]]
# Cell-specific modality weights can be accessed at bm$RNA.weight
bm_data <- FindMultiModalNeighbors(
  bm_data, reduction.list = list("pca", "apca"), 
  dims.list = list(1:30, 1:18), modality.weight.name = "RNA.weight"
)

```

```{r}
bm_data <- RunUMAP(bm_data, nn.name = "weighted.nn", reduction.name = "wnn.umap", reduction.key = "wnnUMAP_")
bm_data <- FindClusters(bm_data, graph.name = "wsnn", algorithm = 3, resolution = 2, verbose = FALSE)

```

```{r, fig.width= 10}

p1 <- DimPlot(bm_data, reduction = 'wnn.umap', label = TRUE, repel = TRUE, label.size = 2.5) + 
  theme_minimal() +
  labs(title = 'Clusters') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)+
  NoLegend()
p2 <- DimPlot(bm_data, reduction = 'wnn.umap', group.by = 'celltype.l2', label = TRUE, repel = TRUE, label.size = 2.5) + 
  theme_minimal() +
  labs(title = 'Cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05) +
  NoLegend()

p1 + p2


```

```{r}
bm_data <- RunUMAP(bm_data, reduction = 'pca', dims = 1:30, assay = 'RNA', 
              reduction.name = 'rna.umap', reduction.key = 'rnaUMAP_')
bm_data <- RunUMAP(bm_data, reduction = 'apca', dims = 1:18, assay = 'ADT', 
              reduction.name = 'adt.umap', reduction.key = 'adtUMAP_')

```

```{r, fig.width= 10}

p3 <- DimPlot(bm_data, reduction = 'rna.umap', group.by = 'celltype.l2', label = TRUE, 
              repel = TRUE, label.size = 2.5) + 
  theme_minimal() +
  labs(title = 'RNA cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)+
  NoLegend()
p4 <- DimPlot(bm_data, reduction = 'adt.umap', group.by = 'celltype.l2', label = TRUE, 
              repel = TRUE, label.size = 2.5) + 
  theme_minimal() +
  labs(title = 'ADT cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)+
  NoLegend()
p3 + p4

```

```{r, fig.width= 10}

p5 <- FeaturePlot(bm_data, features = c("adt_CD45RA","adt_CD16","adt_CD161"),
                  reduction = 'wnn.umap', max.cutoff = 2, 
                  cols = c("grey","darkgreen"), ncol = 3)
p6 <- FeaturePlot(bm_data, features = c("rna_TRDC","rna_MPO","rna_AVP"), 
                  reduction = 'wnn.umap', max.cutoff = 3, ncol = 3)
p5 / p6

```

```{r, fig.width= 9}
 VlnPlot(bm_data, features = "RNA.weight", group.by = 'celltype.l2', sort = TRUE, pt.size = 0.1) +
  NoLegend()

```

```{r}
compute_silhouette(bm_data@reductions$rna.umap@cell.embeddings, bm_data@meta.data$celltype.l2, result_format = 'plot') +
  labs(title = 'Silhouette coef. of RNA UMAP per cell type')

```

```{r}
compute_silhouette(bm_data@reductions$adt.umap@cell.embeddings, bm_data@meta.data$celltype.l2, result_format = 'plot') +
  labs(title = 'Silhouette coef. of ADT UMAP per cell type')

```

```{r}
compute_silhouette(bm_data@reductions$wnn.umap@cell.embeddings, bm_data@meta.data$celltype.l2, result_format = 'plot') +
  labs(title = 'Silhouette coef. of WNN UMAP per cell type')

```

```{r}

bm_mofa <- MOFA2::create_mofa_from_Seurat(bm_data, 
                                          groups = NULL, 
                                          assays = c('RNA', 'ADT'),
                                          features = list(bm_data@assays$RNA@features@.Data,
                                                          bm_data@assays$ADT@features@.Data))

# need to use stochastic variational inference since our data is too big.
params <- MOFA2::get_default_training_options(bm_mofa)
params$stochastic <- T

bm_mofa <- MOFA2::prepare_mofa(bm_mofa, training_options = params)
bm_mofa <- MOFA2::run_mofa(bm_mofa, use_basilisk = T)

# saving the MOFA obj onto vast since this took 1.5hrs to finish

# saveRDS(bm_mofa, file = '/vast/scratch/users/liu.ne/bm_mofa_all_features.rds')

bm_mofa <- readRDS('/vast/scratch/users/liu.ne/bm_mofa_all_features.rds')

```

```{r}
p1 <- MOFA2::plot_variance_explained(bm_mofa)

p1

```

Now run UMAP on the MOFA factors and plot

```{r}

bm_data <- MOFA2::add_mofa_factors_to_seurat(mofa_object = bm_mofa, seurat_object =  bm_data, 
                                  views = 'all', factors = 'all')

bm_data <- RunUMAP(bm_data, reduction = 'MOFA', dims = c(1:25)[-9], reduction.name = 'MOFA_UMAP')

```

```{r, fig.width= 9}

DimPlot(bm_data, reduction = 'MOFA_UMAP', group.by = 'celltype.l2', label = T,
                      repel = TRUE, label.size = 2.5) + 
  theme_minimal() +
  labs(title = 'MOFA cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05) +
  NoLegend()


```

```{r}
compute_silhouette(bm_data@reductions$MOFA_UMAP@cell.embeddings, bm_data@meta.data$celltype.l2, 
                   result_format = 'plot')


```


To benchmark with other methods such as totalVI, we need to use the reticulate package to operate python in R. 

```{r}
library(zellkonverter)

DefaultAssay(bm_data) <- 'ADT'
test <- Seurat::as.SingleCellExperiment(bm_data)
DefaultAssay(bm_data) <- 'RNA'
test1 <- Seurat::as.SingleCellExperiment(bm_data)
zellkonverter::writeH5AD(test, file = '/vast/scratch/users/liu.ne/bm_ADT.h5ad')
zellkonverter::writeH5AD(test1, file = '/vast/scratch/users/liu.ne/bm_RNA.h5ad')


```

Trying to run tilted-CCA

```{r}
rna_matrix <- Matrix::t(bm_data[['RNA']]$scale.data)
adt_matrix <- Matrix::t(bm_data[['ADT']]$scale.data)

set.seed(10)
multi_SVD <- tiltedCCA::create_multiSVD(mat_1 = rna_matrix, mat_2 = adt_matrix, 
                                        dims_1 = 1:30, dims_2 = 1:18,
                                        scale_1 = F, scale_2 = F)

Seurat::DefaultAssay(bm_data) <- 'RNA'
bm_data <- Seurat::FindNeighbors(bm_data, reduction = 'pca', dims = 1:30, return.neighbor = T)
bm_data <- Seurat::FindClusters(bm_data, graph.name = 'RNA_snn', resolution = 0.25)
Seurat::DefaultAssay(bm_data) <- 'ADT'
bm_data <- Seurat::FindNeighbors(bm_data, reduction = 'apca', dims = 1:18, return.neighbor = T)
bm_data <- Seurat::FindClusters(bm_data, graph.name = 'ADT_snn', resolution = 0.25)


multi_SVD <- tiltedCCA::form_metacells(multi_SVD,
                                       large_clustering_1 = bm_data$RNA_snn_res.0.25,
                                       large_clustering_2 = bm_data$ADT_snn_res.0.25)

multi_SVD <- tiltedCCA::compute_snns(multi_SVD, num_neigh = 30, latent_k = 20)

multi_SVD <- tiltedCCA::tiltedCCA(multi_SVD, verbose = 1)

# This part takes VERY long (more than 6 hours). 
multi_SVD <- tiltedCCA::fine_tuning(multi_SVD, verbose = 1) |> tiltedCCA_decomposition(verbose = 1)

saveRDS(multi_SVD, file = '/vast/scratch/users/liu.ne/bm_CITEseq_tiltedCCA.rds')


```

```{r}
bm_data[['tcca_common']] <- tiltedCCA::create_SeuratDim(multi_SVD, what = 'common', seurat_obj = bm_data, 
                                                        aligned_umap_assay = 'MOFA_UMAP', verbose = 1)

bm_data[['tcca_distinct_rna']] <- tiltedCCA::create_SeuratDim(multi_SVD, what = 'distinct_1', seurat_obj = bm_data, 
                                                        aligned_umap_assay = 'MOFA_UMAP', verbose = 1)

bm_data[['tcca_distinct_adt']] <- tiltedCCA::create_SeuratDim(multi_SVD, what = 'distinct_2', seurat_obj = bm_data, 
                                                        aligned_umap_assay = 'MOFA_UMAP', verbose = 1, seurat_assay = 'ADT')

```

```{r, fig.width= 10}

DimPlot(bm_data, reduction = 'tcca_common', group.by = 'celltype.l2', label = T, repel = T, label.size = 2.5)+
  theme_minimal() +
  labs(title = 't-CCA common cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05) +
  NoLegend()

```

```{r}
compute_silhouette(bm_data[['tcca_common']]@cell.embeddings, label_vector = bm_data$celltype.l2, result_format = 'plot')

```




```{r, fig.width= 10}

p1 <- DimPlot(bm_data, reduction = 'tcca_distinct_rna', group.by = 'celltype.l2', label = T, repel = T, label.size = 2.5)+
  theme_minimal() +
  labs(title = 't-CCA RNA distinct cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05) +
  NoLegend()

p2 <- DimPlot(bm_data, reduction = 'tcca_distinct_adt', group.by = 'celltype.l2', label = T, repel = T, label.size = 2.5)+
  theme_minimal() +
  labs(title = 't-CCA ADT distinct cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05) +
  NoLegend()

p1 + p2

```

```{r}
compute_silhouette(bm_data[['tcca_distinct_rna']]@cell.embeddings, label_vector = bm_data$celltype.l2, result_format = 'plot')
```
```{r}
compute_silhouette(bm_data[['tcca_distinct_adt']]@cell.embeddings, label_vector = bm_data$celltype.l2, result_format = 'plot')

```

```{r, fig.width= 8}

library(parallel)

all_silhouette_scores <- parallel::mclapply(list(bm_data@reductions$rna.umap@cell.embeddings,
                                  bm_data@reductions$adt.umap@cell.embeddings,
                                  bm_data@reductions$wnn.umap@cell.embeddings,
                                  bm_data@reductions$MOFA_UMAP@cell.embeddings,
                                  bm_data[['tcca_common']]@cell.embeddings, 
                                  bm_data[['tcca_distinct_rna']]@cell.embeddings, 
                                  bm_data[['tcca_distinct_adt']]@cell.embeddings), 
                             function(x){compute_silhouette(matrix = x, label_vector = bm_data$celltype.l2, 
                                                            result_format = 'per_cluster')})

all_silhouette_scores <- do.call(rbind, all_silhouette_scores)
all_silhouette_scores$algorithm <- rep(c('raw_RNA', 'raw_ADT', 'WNN', 'MOFA', 't-CCA_common', 't-CCA_unique_RNA', 't-CCA_unique_ADT'), each = 27)

plot_boxplot_categorical(all_silhouette_scores$silhouette_score, all_silhouette_scores$algorithm, names = c('sihouette score', 'algorithm')) +
  theme(axis.text.x = element_text(size = 10,angle = 45,hjust = 1))

```

```{r, fig.width= 8}
# install.packages('ggbeeswarm')
library(ggbeeswarm)

plot_violin(all_silhouette_scores$silhouette_score, all_silhouette_scores$algorithm, names = c('silhouette','algorithm')) + 
  coord_cartesian(ylim = c(-1, 1.4))

```



```{r}
# devtools::install_github("immunogenomics/lisi")
library(lisi)

LISI_scores <- compute_lisi(bm_data@reductions$pca@cell.embeddings[,1:20], 
                            meta_data = bm_data@meta.data, 
                            label_colnames = c('lane', 'donor', 'celltype.l2')) |> cbind.data.frame(dplyr::select(bm_data@meta.data, c('lane', 'donor', 'celltype.l2')))

colnames(LISI_scores) <- c('lane_score', 'donor_score', 'celltype_score', 'lane', 'donor', 'celltype')

```

```{r, fig.width= 12}
plot_ridgeplot(LISI_scores$celltype_score, LISI_scores$celltype, c('LISI for lane', 'lane'))

```

```{r, fig.width= 12}
adt_plot_data <- tidyr::pivot_longer(as.data.frame(bm_data@assays$ADT@layers$scale.data), 
                                     cols = everything())
adt_plot_data$cell_labels <- rep(bm_data$celltype.l2, each = 25)

plot_ridgeplot(adt_plot_data$value, adt_plot_data$cell_labels, c('adt', 'celltype'))

```

```{r, fig.width= 12}
adt_plot_data <- ADTnorm::arcsinh_transform(t(as.matrix(bm_data@assays$ADT@layers$counts))) %>% as.data.frame () %>% tidyr::pivot_longer(cols = everything())

adt_plot_data$cell_labels <- rep(bm_data$celltype.l2, each = 25)

plot_ridgeplot(adt_plot_data$value, adt_plot_data$cell_labels, c('adt', 'celltype'))

```

```{r, fig.height= 10, fig.width= 9}
library(ggridges)

adt_arcsinh_data <- ADTnorm::arcsinh_transform((as.matrix(bm_data@assays$ADT@layers$counts)) %>% as.data.frame())
rownames(adt_arcsinh_data) <- bm_data@assays$ADT@meta.data$var.features

p <- plot_ridgeplot(matrix= adt_arcsinh_data[,], label_vector = bm_data$donor)

p

```

```{r}
# Normalize with ADTnorm, CLR & DSB
adt_data <- as.matrix(bm_data@assays$ADT@layers$counts)
rownames(adt_data) <- bm_data@assays$ADT@meta.data$var.features

adt_counts_umap <- umap(t(adt_data))$layout %>% as.data.frame()

p <- plot_UMAP(adt_counts_umap, metadata_vector = bm_data$celltype.l2, title = 'UMAP of ADT raw counts', run_umap = F)
p <- p + labs(color = 'celltype l2')

p
```

```{r}
library(viridis)

df <- adt_counts_umap
df$metadata <- bm_data$nCount_RNA

lim = 4000
df$metadata <- lapply(df$metadata, function(x) ifelse(x > lim, lim, x)) %>% unlist() %>% log2()



ggplot(df, aes(x = V1, y = V2, color = metadata)) +
    geom_point(size = 0.07) +
    scale_fill_viridis() +
    scale_color_viridis() +
    ggtitle('UMAP ADT raw counts with RNA libsize') +
    theme_minimal() +
    labs(color = 'RNA Libsize (log2)') +
    theme(axis.line = element_line(colour = "grey83", linewidth = 1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)


```
```{r}
df <- adt_counts_umap
df$metadata <- bm_data$nCount_ADT

lim = 10000
df$metadata <- lapply(df$metadata, function(x) ifelse(x > lim, lim, x)) %>% unlist() %>% log2()

plot_UMAP(df, df$metadata, title = 'UMAP ADT raw counts with total ADT counts', 
          run_umap = F, label_is_continuous = T) +
  labs(color = 'total ADT counts log2')

```


```{r}

compute_silhouette((adt_data), run_dim_reduction = 'umap', bm_data$celltype.l2, result_format = 'plot') +
  ggtitle('ADT raw counts')


```

```{r}

compute_silhouette((bm_data@assays$ADT$data), run_dim_reduction = 'umap', bm_data$celltype.l2, result_format = 'plot') +
  ggtitle('ADT CLR')


```



```{r}
adt_dsb <- dsb::ModelNegativeADTnorm(t(adt_data), use.isotype.control = F)

compute_silhouette(t(adt_dsb), run_dim_reduction = 'umap', bm_data$celltype.l2, result_format = 'plot') +
  ggtitle('ADT DSB')

```
```{r}
compute_silhouette(totalVI_adt@assays@data@listData$normalized_data, totalVI_adt$celltype.l2, 
                   run_dim_reduction = 'umap', result_format = 'plot') +
  ggtitle('ADT totalVI')

```

Now we'll run ADTnorm

```{r, fig.width= 10}
data <- t(adt_data)
rownames(data) <- rownames(bm_data@meta.data)
metadata <- bm_data@meta.data
metadata$sample <- bm_data$donor

adt_adtnorm <- ADTnorm(data, metadata, save_outpath = '/vast/scratch/users/liu.ne/')
adt_adtnorm <- t(adt_adtnorm)

```
Load our totalVI normalized data from python into R.

```{r}
library(zellkonverter)
totalVI_adt <- zellkonverter::readH5AD('/vast/scratch/users/liu.ne/totalVI_adt.h5ad')

totalVI_normalized <- totalVI_adt@assays@data@listData$normalized_data

```

```{r}

normalized_adt_all_methods <- list((adt_data),
                                   (bm_data@assays$ADT@layers$data),
                                   t(adt_dsb),
                                   adt_adtnorm,
                                   totalVI_normalized)

umap_normalized_adt_all_methods <- parallel::mclapply(normalized_adt_all_methods, 
                                                      function(x){umap(t(x))$layout})
names(umap_normalized_adt_all_methods) <- c('Raw counts', 'CLR', 'DSB', 'ADTnorm', 'totalVI')

umap_normalized_adt_all_methods <- lapply(umap_normalized_adt_all_methods, as.data.frame)

all_silhouette_scores <- parallel::mclapply(umap_normalized_adt_all_methods,
                                            function(x){compute_silhouette(matrix = x, label_vector = bm_data$celltype.l2, run_dim_reduction = NULL,
                                                            result_format = 'per_cluster')})

all_silhouette_scores <- do.call(rbind, all_silhouette_scores)
all_silhouette_scores$algorithm <- rep(c('Raw counts', 'CLR', 'DSB', 'ADTnorm', 'totalVI'), each = 27)

plot_boxplot_categorical(all_silhouette_scores$silhouette_score, all_silhouette_scores$algorithm, names = c('Silhouette score', 'Method')) +
  theme(axis.text.x = element_text(size = 10,angle = 45,hjust = 1))  +
  theme(legend.position = 'None')


```

```{r}
plot_violin(all_silhouette_scores$silhouette_score, all_silhouette_scores$algorithm, names = c('Silhouette scores per cell type', 'Method'), overlay_type= 'boxplot') +
  theme(axis.text.x = element_text(size = 10,angle = 45,hjust = 1)) +
  theme(legend.position = 'None')


```

```{r}
plot_ridgeplot(tidyr::pivot_wider(all_silhouette_scores, 
                                   names_from = contains('algorithm'), 
                                   values_from = where(is.numeric))[,7:11], 
                label_vector = c('Raw counts', 'CLR', 'DSB', 'ADTnorm', 'totalVI'),
               title = 'Ridgeplot of silhouette coefficients for celltypes')


```

```{r}
plot_vector_correlation(normalized_adt_all_methods, c('Raw counts', 'CLR', 'DSB', 'ADTnorm', 'totalVI'), 
                        bm_data$celltype.l2,'L2 celltype', is.pca.obj = F)


```

```{r}
plot_linear_correlation(normalized_adt_all_methods, c('Raw counts', 'CLR', 'DSB', 'ADTnorm', 'totalVI'), 
                        bm_data$nCount_ADT,'ADT libsize', is.pca.obj = F)

```

Now compute ARI scores

```{r}

ARI_scores <- parallel::mclapply(umap_normalized_adt_all_methods,
                                 function(x){compute_ARI(matrix = x, label_vector = bm_data$celltype.l2, run_dim_reduction = NULL)})

ARI_scores <- data.frame(ARI_score = unlist(ARI_scores),
                         algorithm = c('Raw counts', 'CLR', 'DSB', 'ADTnorm', 'totalVI'))

ggplot(ARI_scores, aes(y = ARI_score,  x = algorithm, fill = algorithm))+
  geom_col() +
  theme_minimal() +
  labs(x= 'algorithm', y= 'ARI score') +
  theme(axis.line = element_line(colour = "grey83", linewidth = 1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.2,
        legend.position = 'None') +
  ggtitle('ARI score for each method')
  

```

```{r, fig.size = 6}
adt_libsize_plots <- parallel::mclapply(umap_normalized_adt_all_methods, 
                                 function(x, name){plot_UMAP(x, log2(bm_data$nCount_ADT), 
                                                       run_umap = F,
                                                       label_is_continuous = T,
                                                       title = paste0(name,' labelled by ADT libsize'))
                                   },names(umap_normalized_adt_all_methods))

adt_libsize_plots

```

```{r}
adt_celltype_plots <- parallel::mclapply(umap_normalized_adt_all_methods, 
                                 function(x, name){plot_UMAP(x, bm_data$celltype.l2,
                                                             run_umap = F,
                                                             label_is_continuous = F)})

adt_celltype_plots

```

```{r}

triana_2021 <- readRDS(file = '/vast/scratch/users/liu.ne/41038073')

DefaultAssay(triana_2021) <- 'RNA'
triana_2021 <- NormalizeData(triana_2021) %>% FindVariableFeatures() %>% ScaleData() %>% RunPCA(reduction.name='rna_pca')
triana_2021 <- Seurat::RunUMAP(triana_2021, reduction = 'rna_pca', dims = 1:30, reduction.name = 'rna_umap')

DefaultAssay(triana_2021) <- 'AB'
# VariableFeatures(triana_2021) <- rownames(triana_2021[["AB"]])
triana_2021 <- RunPCA(triana_2021, reduction.name = 'adt_pca')
triana_2021 <- RunUMAP(triana_2021, reduction = 'adt_pca', reduction.name = 'adt_umap', dims = 1:30)


```


```{r, fig.width= 10}

p1 <- Seurat::DimPlot(triana_2021, reduction = 'rna_umap', label = T, repel = T, label.size = 2.5) + 
  theme_minimal() +
  labs(title = 'RNA UMAP cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)+
  NoLegend()
p2 <- Seurat::DimPlot(triana_2021, reduction = 'adt_umap', label = T, repel = T, label.size = 2.5) +
  theme_minimal() +
  labs(title = 'ADT UMAP cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)+
  NoLegend()

p1+p2

```

```{r}

# for RNA normalization:
# LIGER

# use Seurat IntegrateLayers for fastMNN
# Seurat::CCAIntegration()
# Seurat::RPCAIntegration()


```



```{r}

# Run harmony

bm_data <- harmony::RunHarmony(bm_data, 
                               group.by.vars = 'donor',
                               reduction.use = 'pca')

bm_data <- Seurat::RunUMAP(bm_data, 
                           reduction = 'harmony', 
                           reduction.name = 'harmony_umap', 
                           dims = 1:30)

# Run SCtransform

bm_data <- Seurat::SCTransform(bm_data, 
                               variable.features.n = 2000)
bm_data <- Seurat::RunPCA(bm_data, 
                          reduction.name = 'SCT_pca') %>% RunUMAP(reduction = 'SCT_pca',
                                                                  dims = 1:30, 
                                                                  reduction.name = 'SCT_umap')

```


```{r, fig.width=10}

p1 <- Seurat::DimPlot(bm_data, reduction = 'harmony_umap', 
                group.by = 'celltype.l2', label = T, repel = T, label.size = 2.5) + 
  NoLegend() +
  labs(title = 'UMAP of Harmony adjusted PCs') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)

p2 <- Seurat::DimPlot(bm_data, reduction = 'SCT_umap', 
                group.by = 'celltype.l2', label = T, repel = T, label.size = 2.5) + 
  NoLegend() +
  labs(title = 'UMAP of SCTransformed raw counts') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05)

p1 + p2

```

# Doing RUVIII normalization

## PRPS

### Since there's no NCG function yet we'll have to make one.

```{r}

# NOT ROBUST TO LOWLY EXPRESSED GENES
# try doing intersection instead of ranking

setGeneric(name = 'find_corr',
           function(data, variable_vector){standardGeneric('find_corr')})

setMethod('find_corr',
          signature = c(variable_vector = 'numeric'),
          function(data, variable_vector){
            results <- Rfast::correls(y=variable_vector, x=t(data), type = 'spearman') %>% as.data.frame()
            return(as.vector(results$correlation))
          })

setMethod('find_corr',
          signature = c(variable_vector = 'character'),
          function(data, variable_vector){
            #results <- ftest(data, variable_vector)
            results <- parallel::mclapply(1:nrow(data),
                                          function(x){summary(aov(as.vector(data[x,])~variable_vector))[[1]][4][1,1]})
            return((unlist(results)))
          })


setGeneric(name = 'FindNCG',
           function(object,
                    unwanted_variables,
                    bio_variables,
                    no.ncg = 1000,
                    apply_log = T,
                    sample_fraction = 0.1)
             {standardGeneric('FindNCG')})


setMethod('FindNCG', 
          signature = c(object = 'Seurat',
                        unwanted_variables = 'character',
                        bio_variables = 'character'),
          function(object,
                   unwanted_variables,
                   bio_variables,
                   no.ncg,
                   apply_log,
                   sample_fraction){
            
            message(paste0('Sampling ', sample_fraction * ncol(object),' cells from your data'))
            object1 <- object[,sample(ncol(object), sample_fraction * ncol(object))]
            
            
            # Hardcoding main data matrix to assays > RNA > layers > counts
            
            if(apply_log){data <- log2(object1@assays$RNA@layers$counts+1)}
            else{data <- object1@assays$RNA@layers$counts}
            
            message('Calculating Spearman correlation for continuous variables & F score for categorical variables')
            corr_data <- parallel::mclapply(c(unwanted_variables, bio_variables), 
                                          function(x){find_corr(as.matrix(data), object1@meta.data[[x]])})
            
            names(corr_data) <- c(unwanted_variables, bio_variables)
            View(corr_data)
            
            # Flip bio variables 
            message('Finding genes highly affected by unwanted variables but not affected by biological variables')
            for(name in names(corr_data)){
              if(name %in% bio_variables){
                corr_data[[name]] <- corr_data[[name]] * (-1)
              }
            }
            
            corr_data <- do.call(cbind, corr_data) %>% as.data.frame()
            rownames(corr_data) <- rownames(object[['RNA']])
            # corr_data <- remove_NA_rows(corr_data, 0.1)
            
            # Rank the data
            ranks <- apply(corr_data, 2, rank) %>% as.data.frame()
            ranks$avg_expr <- rowMeans2(data)
            # print(ranks)
            prod_ranks <- apply(ranks, 1, prod)
            final_gene_ranks <- prod_ranks[base::order(-prod_ranks)]
            message('FindNCG Completed!')
            
            return(names(final_gene_ranks)[1:no.ncg])
            
          })

```

```{r}

bm_data$log2_libsize <- log2(colSums(bm_data@assays$RNA@layers$counts))
DefaultAssay(bm_data) <- 'RNA'

ncg <- FindNCG(bm_data1, 
               c('log2_libsize', 'donor'), 
               c('celltype.l2'), 
               sample_fraction = 0.1, no.ncg = 1000)
```

```{r}

ncg_pca <- list(BiocSingular::runSVD(t(bm_data@assays$RNA@layers$counts[which(rownames(bm_data@assays$RNA) %in% ncg),]), 
                                     k=10, center=T, BSPARAM = bsparam()))[[1]]

ggplot(mapping = aes(x=ncg_pca$u[,1], y=bm_data$log2_libsize))+
  geom_point(alpha=0.62, color= 'grey30') + # alpha for transparency to see overlap
  labs(x="PC1 of NCGs", 
       y="log2 libsize") +
  theme_minimal()+
  ggtitle('1st PC of negative control genes vs log2 libsize') +
  theme(panel.border=element_rect(colour = "grey80", fill=NA, size=0.8),
        aspect.ratio = 1/1.1,
        axis.line = element_line(colour = "grey75", linewidth = 1.1),
        panel.grid.major = element_line(color = "grey96"))

```
```{r}
plot_vector_correlation(list(ncg_pca), c('ncg_pca'), bm_data$celltype.l2, 'celltypes')

```
```{r}
p1 <- plot_PCA(ncg_pca, 'ncg_pca', bm_data$celltype.l2, 'celltypes', is_pca_obj = T)
p2 <- plot_PCA(ncg_pca, 'ncg_pca', bm_data$log2_libsize, 'libsize', is_pca_obj = T, is_continuous = T)

gridExtra::grid.arrange(p1,p2, ncol=2)

```


```{r, fig.width= 15}
# bsparam()

ncgs_log2 <- log2(bm_data@assays$RNA@layers$counts[which(rownames(bm_data1@assays$RNA) %in% ncg),]+1)

control_genes_pca <- BiocSingular::runSVD(t(ncgs_log2), 
                                          k = 30,
                                          BSPARAM = bsparam())
ncgs_umap <- umap((control_genes_pca$u))

plot_UMAP(ncgs_umap$layout, bm_data$celltype.l2, run_umap = F) +
  xlim(c(-8,8)) +
  ylim(c(-8,8))

```



```{r}

# THE SEURAT CANNOT HAVE ANYTHING in 'graphs' or else the subsetting throws error. (no slot i in class graph or something)
# v5 needs to do RNA@layers$counts instead of just RNA@counts otherwise will throw weird error (no slot counts for class Array5 or something)

# source('~/Edited_HelperFunctions_scMultiOmics_SuperFastRUVIIIPrPs.R')


# try setting cell names to celltype labels (every cell is a replicate of each other) when you compute the M matrix

# also try not setting batch
prpc <- sc_PRPC_v2(bm_data1,
                libSize = 'log2_libsize',
                batch = 'donor',
                libSize.prps = T,
                batch.prps = T)

# pro.bar <- progress_estimated(round(lo/grid.nb, digits = 0) + 2)
# pro.bar$pause(0.1)$tick()$print()

# This function DOES NOT do log for you.

M <- ruv::replicate.matrix(rownames(prpc))
Y <- as.matrix(t(log2(bm_data@assays$RNA@layers$counts+1)))

rna_ruviii <- RUV_III(Y = Y,
                      Yrep = prpc,
                      M = M,
                      ctl = rownames(bm_data1@assays$RNA) %in% ncg,
                      k = 2,
                      return.info = T)


### matrixStats is very fast
rna_ruviii <- rna_ruviii$newY

# Since the dense matrix is very big we'll round to 2 digits and convert to sparse 
rna_ruviii[rna_ruviii<0] <- 0
rna_ruviii <- round(rna_ruviii, digits = 2) %>% as.sparse()
rna_ruviii <- t(rna_ruviii)
rownames(rna_ruviii) <- rownames(bm_data@assays$RNA)
colnames(rna_ruviii) <- colnames(bm_data@assays$RNA)

# Find variable genes so we don't have to do PCA on all 17000 genes and blow up our RAM
# We're not using Seurat's FindVariableFeatures since the errors are a bit enigmatic.
# hvgs <- (parallel::mclapply(1:nrow(rna_ruviii), function(x){mad(as.vector(rna_ruviii[x,]))}))
# names(hvgs) <- rownames(bm_data@assays$RNA)
# hvgs <- names(sort(unlist(hvgs), decreasing = T)[1:2000])

seurat_hvgs <- rownames(bm_data@assays$RNA@features)[bm_data@assays$RNA@features[,3]]
```


```{r}
a <- edgeR::filterByExpr(bm_data@assays$RNA@layers$counts, min.count = 2, min.total.count = 10)
sum(a)

```


```{r}
plot(rna_ruviii_w[,2], bm_data$log2_libsize)

plot(rna_ruviii_w[,2], col= as.factor(bm_data$celltype.l2))


```

```{r}
M <- ruv::replicate.matrix(bm_data$celltype.l2)
Y <- as.matrix(t(log2(bm_data@assays$RNA@layers$counts+1)))
colnames(Y) <- rownames(bm_data@assays$RNA)

rna_ruviii <- RUV_III(Y = Y,
                      Yrep = Y,
                      M = M,
                      ctl = rownames(bm_data1@assays$RNA) %in% ncg,
                      k = 2,
                      return.info = T)

rna_ruviii_w <- rna_ruviii$W

```

```{r}
plot(rna_ruviii_w[,2], bm_data$log2_libsize)

plot(rna_ruviii_w[,1], col= as.factor(bm_data$celltype.l2))

```


## Run dim reduction
```{r}
# turn into sparse matrix
rna_ruviii[rna_ruviii<0] <- 0
rna_ruviii <- round(rna_ruviii, digits = 4) %>% as.sparse()
rna_ruviii <- t(rna_ruviii)
rownames(rna_ruviii) <- rownames(bm_data@assays$RNA)
colnames(rna_ruviii) <- colnames(bm_data@assays$RNA)
```

```{r}
rna_ruv_pca <- list(BiocSingular::runSVD(t(rna_ruviii[seurat_hvgs,]), k=30, center=T, BSPARAM = bsparam()))[[1]]
rna_ruv_pca_scaled <- list(BiocSingular::runSVD(scale(t(as.matrix(rna_ruviii[seurat_hvgs,]))), k=30, center=T, BSPARAM = bsparam()))[[1]]
rna_ruv_umap <- umap(rna_ruv_pca$u)
rna_ruv_umap_scaled <- umap(rna_ruv_pca_scaled$u)

```

```{r}
plot_UMAP(rna_ruv_umap$layout, bm_data$log2_libsize, run_umap = F, 
          label_is_continuous = T, continuous_var_upper_lim = 12)

```

```{r}
plot_UMAP(rna_ruv_umap$layout, bm_data$celltype.l2, run_umap = F, 
          label_is_continuous = F)

```

```{r}
plot_UMAP(rna_ruv_umap_scaled$layout, bm_data$celltype.l2, run_umap = F, 
          label_is_continuous = F)

```



```{r}
plot_UMAP(bm_data@reductions$rna.umap@cell.embeddings, bm_data$log2_libsize, 
          run_umap = F, label_is_continuous = T, continuous_var_upper_lim = 12)

```


```{r}
Seurat::DimPlot(bm_data, reduction = 'rna.umap', group.by = 'celltype.l2', label = T, repel = T, label.size = 2.5) +
    theme_minimal() +
  labs(title = 'Cell types') +
  theme(axis.line = element_line(colour = "grey83", linewidth=1.1),
          panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
          panel.grid.major = element_line(color = "grey96"),
          aspect.ratio = 1/1.05) +
  NoLegend()

```

```{r, fig.height= 8}
p1 <- plot_ridgeplot(colsums(log2(as.matrix(bm_data@assays$RNA@layers$counts)+1)), bm_data$celltype.l2, aspect_ratio = 1/0.6, title = 'Ridgeplot of log2 libsize per celltype')

p2 <- plot_ridgeplot(colsums(as.matrix(rna_ruviii)), bm_data$celltype.l2, aspect_ratio = 1/0.6, title = 'Ridgeplot of log2 libsize per celltype')

p1 <- p1 + xlim(0,6000)
p2 <- p2 + xlim(0,6000)

gridExtra::grid.arrange(p1,p2, ncol=2)

```



```{r}
rna_ruv_k6_pca <- run_PCA(rna_ruviii[hvgs,], pcs = 50)
rna_ruv_k6_umap <- umap(rna_ruv_k6_pca$u[,1:30])

```


```{r}
plot_UMAP(rna_ruv_k6_umap$layout, bm_data$celltype.l2, run_umap = F)

```



```{r}

plot_UMAP(bm_data@reductions$rna.umap@cell.embeddings, 
          bm_data$log2_libsize, label_is_continuous = T, run_umap = F,
          continuous_var_upper_lim = 12,
          title = 'UMAP of log2 libsize of RNA raw counts')


```


```{r}

DefaultAssay(bm_data1) <- 'RUVIII'
bm_data1@assays$RUVIII@misc <- list()
bm_data1@assays$RUVIII@key <- 'ruviii_'

# THIS WILL ERROR
# bm_data1 <- FindVariableFeatures(bm_data1) %>% RunPCA(reduction.name = 'ruv_k6_pca') %>% RunUMAP(dims = 1:30, reduction.name = 'ruv_k6_umap')


```


## Liger

### NONE OF THESE ARE WORKING
```{r}
# openBLAS/0.3.23-gcc-11.3.0

# Both of these dont work
 devtools::install_github('welch-lab/RcppPlanc')
# install.packages('RcppPlanc', repos = c('https://welch-lab.r-universe.dev', 'https://cloud.r-project.org'))

# install.packages("RcppPlanc", repos = c(linux = 'https://welch-lab.r-universe.dev/bin/linux/jammy/4.3',
#                                        sources = 'https://welch-lab.r-universe.dev',
#                                        cran = 'https://cloud.r-project.org'))

DefaultAssay(bm_data1) <- 'RNA'
bm_list <- Seurat::SplitObject(bm_data1, split.by = "donor")
bm_liger <- rliger::createLiger(bm_list)

liger_normalized <- rliger::normalize(bm_liger) %>% selectGenesVST(useDataset = 1) %>% scaleNotCenter()
liger_normalized <- rliger::runIntegration(liger_normalized, k=20)

```

```{r}
# liger_normalized_scaled <- rliger::scaleNotCenter(liger_normalized[seurat_hvgs,])

liger_pca <- run_PCA(liger_normalized[seurat_hvgs,], pcs = 50)
liger_pca_scaled <- run_PCA(liger_normalized_scaled, pcs = 50)

rownames(liger_pca$u) <- colnames(bm_data)
bm_data@reductions$liger_pca <- CreateDimReducObject(embeddings = liger_pca$u, key = 'pc_')
# bm_data <- RunUMAP(bm_data, reduction = 'liger_pca', dims = 1:30)

liger_umap <- uwot::umap(liger_pca$u[,1:30],init = 'pca', metric = 'cosine', n_neighbors = 30)

plot_UMAP(liger_umap, run_umap = F, bm_data$celltype.l1)

```



## fastMNN
```{r}

# batchelor::fastMNN( log transformed matrix (cols as cells rows as genes), batch = vector, subset.row = vector of highly variable genes )

# This is seurat log normalized but not scaled.
bm_fastMNN <- batchelor::fastMNN(as.matrix(bm_data@assays$RNA@layers$data),
                                 batch = bm_data$donor,
                                 subset.row = as.vector(bm_data@assays$RNA@features[,3]))

bm_fastMNN_pcs <- bm_fastMNN_pcs@int_colData$reducedDims$corrected
rownames(bm_fastMNN_pcs) <- colnames(bm_data)

mnn_dim_reduc <- CreateDimReducObject(embeddings = bm_fastMNN_pcs, key = 'mnn_')
bm_data@reductions$fastMNN <- mnn_dim_reduc

# fastMNN_umap <- RunUMAP(bm_data, dims = 1:30, reduction = 'fastMNN', reduction.name = 'fastMNN_umap')
bm_data@reductions$fastMNN_umap <- CreateDimReducObject(embeddings = umap(bm_fastMNN_pcs[,1:30])$layout, key = 'mnn_')

plot_UMAP((bm_data@reductions$fastMNN_umap@cell.embeddings), bm_data$celltype.l2, run_umap = F)

```


## Seurat rPCA
```{r}
DefaultAssay(bm_data1) <- 'RNA'
bm_list <- Seurat::SplitObject(bm_data1, split.by = "donor")

bm_list <- lapply(X = bm_list, FUN = function(x) {
    x <- Seurat::NormalizeData(x)
    x <- Seurat::FindVariableFeatures(
      x, 
      selection.method = "vst", 
      nfeatures = 2000)
})

features <- Seurat::SelectIntegrationFeatures(object.list = bm_list)

bm_list <- lapply(X = bm_list, FUN = function(x) {
    x <- Seurat::ScaleData(x, features = features, verbose = FALSE)
    x <- Seurat::RunPCA(x, features = features, verbose = FALSE)
})

bm_anchors_rpca <- Seurat::FindIntegrationAnchors(
  object.list = bm_list, 
  anchor.features = features, 
  reduction = "rpca"
  )

bm_combined_rpca <- Seurat::IntegrateData(
  anchorset = bm_anchors_rpca
  )

# Run dim reduc
# This is scaled!!
bm_data@reductions$rpca_integrated_pca <- Seurat::RunPCA(ScaleData(bm_combined_rpca@assays$integrated))
# bm_data <- RunUMAP(bm_data, reduction = 'rpca_integrated_pca', dims = 1:30, reduction.name = 'rpca_integrated_umap')

bm_data@reductions$rpca_integrated_umap <- SeuratObject::CreateDimReducObject(embeddings = umap(bm_data@reductions$rpca_integrated_pca@cell.embeddings[,1:30])$layout, 
                                                                             key = 'rna_')

```

## Seurat CCA (warning: this might be pretty slow)
```{r}

DefaultAssay(bm_data1) <- 'RNA'
bm_list <- Seurat::SplitObject(bm_data1, split.by = "donor")

bm_list <- lapply(X = bm_list, FUN = function(x) {
    x <- Seurat::NormalizeData(x)
    x <- Seurat::FindVariableFeatures(
      x, 
      selection.method = "vst", 
      nfeatures = 2000)
})

features <- Seurat::SelectIntegrationFeatures(object.list = bm_list)

bm_anchors_cca <- Seurat::FindIntegrationAnchors(
  object.list = bm_list, 
  anchor.features = features,
  reduction = 'cca')

bm_combined_cca <- Seurat::IntegrateData(anchorset = bm_anchors_cca)

# Run dim reduc
# This is scaled!!
bm_data@reductions$cca_integrated_pca_scaled <- Seurat::RunPCA(ScaleData(bm_combined_cca@assays$integrated))
#bm_data <- RunUMAP(bm_data, reduction = 'cca_integrated_pca', dims = 1:30, reduction.name = 'cca_integrated_umap')

bm_data@reductions$cca_integrated_umap <- SeuratObject::CreateDimReducObject(embeddings = umap(bm_data@reductions$cca_integrated_pca_scaled@cell.embeddings[,1:30])$layout, 
                                                                             key = 'rna_')

```

## Add RUV normalization of ADT
```{r}
M <- ruv::replicate.matrix(bm_data$celltype.l2)
Y <- as.matrix(t(log2(bm_data@assays$ADT@layers$counts+1)))
colnames(Y) <- rownames(bm_data@assays$ADT)

adt_ruviii <- RUV_III(Y = Y,
                      Yrep = Y,
                      M = M,
                      #ctl = NULL,
                      k = 1,
                      return.info = T)

adt_ruviii_w <- adt_ruviii$W


# turn into sparse matrix
adt_ruviii <- adt_ruviii$newY
adt_ruviii[adt_ruviii<0] <- 0
adt_ruviii <- round(adt_ruviii, digits = 2)
adt_ruviii <- t(adt_ruviii)
rownames(adt_ruviii) <- rownames(bm_data@assays$ADT)
colnames(adt_ruviii) <- colnames(bm_data@assays$ADT)

# get hvgs
# hvgs <- lapply(1:nrow(rna_ruviii), function(x){mad(as.vector(rna_ruviii[x,]))})
# names(hvgs) <- rownames(bm_data@assays$RNA)
# hvgs <- names(sort(unlist(hvgs), decreasing = T)[1:2500])

# do pca & umap
adt_ruv_pca <- run_PCA(adt_ruviii, pcs = 24)
adt_ruv_umap <- umap(adt_ruv_pca$u[,1:18])

```

## Benchmark performance

```{r}
setClass('BenchmarkMetrics', slots = list(Algorithm = 'character',
                                          Dataset = 'list',
                                          Params = 'list',
                                          RunningTime = 'numeric',
                                          Silhouette = 'list',
                                          ARI = 'data.frame',
                                          LISI = 'data.frame'))

# This does not work and i still dont know why.
# setClass('SeuratBenchmark', contains = c('Seurat','BenchmarkMetrics'), slots = c('BenchmarkMetrics'))

setGeneric("ComputeMultipleSilhouette", 
           function(obj,
                    metrics_obj, 
                    reductions, 
                    silhouette_format = 'per_cluster', 
                    labels) 
             standardGeneric("ComputeMultipleSilhouette"))

setMethod('ComputeMultipleSilhouette', 
          signature = c(obj = 'Seurat', 
                        metrics_obj = 'BenchmarkMetrics',
                        reductions = 'character',
                        labels = 'character'), 
          function(obj, 
                   metrics_obj, 
                   reductions, 
                   silhouette_format, 
                   labels){

            reductions_list <- list()
            for (name in reductions){
              reductions_list[[name]] <- Embeddings(obj, reduction = name)
            }
            
            label_vector <- obj[[labels]][,1]
            silhouettes <- parallel::mclapply(
              reductions_list,
              function(x){
                compute_silhouette(matrix = x,
                                   label_vector = label_vector,
                                   result_format = silhouette_format)})
            
            for (x in names(silhouettes)) {
              metrics_obj@Silhouette[[x]] <- silhouettes[[x]]
              }
            
            return(metrics_obj)
          })


setMethod('ComputeMultipleSilhouette', 
          signature = c(obj = 'list', 
                        metrics_obj = 'BenchmarkMetrics',
                        labels = 'character'), 
          function(obj, 
                   metrics_obj, 
                   reductions, 
                   silhouette_format, 
                   labels){
            # input a list of matrices of dimensionally reduced data (rows are 
            # samples and cols are components), calculate silhouette and store in metrics obj.

            reductions_list <- obj
            silhouettes <- parallel::mclapply(
              reductions_list,
              function(x){
                compute_silhouette(matrix = x,
                                   label_vector = labels,
                                   result_format = silhouette_format)})
            
            for (x in names(silhouettes)) {
              metrics_obj@Silhouette[[x]] <- silhouettes[[x]]
              }
            
            return(metrics_obj)
          })


setGeneric('PlotMultipleSilhouette',
           function(metrics_obj, 
                    subset = 'all', 
                    plot_type = 'violin'){
             standardGeneric('PlotMultipleSilhouette')
             }
           )

setMethod('PlotMultipleSilhouette', 
          signature = c(metrics_obj = 'BenchmarkMetrics'),
          function(metrics_obj, 
                   subset, 
                   plot_type){
            
            if(all(subset == 'all')){
              merged_data <- do.call(rbind, metrics_obj@Silhouette)
              merged_data$method <- rep(names(metrics_obj@Silhouette), 
                                        each = length(unique(merged_data$labels)))
            }
            else if(sum(subset %in% names(metrics_obj@Silhouette)) == length(subset)){
              merged_data <- do.call(rbind, metrics_obj@Silhouette[subset])
              merged_data$method <- rep(names(metrics_obj@Silhouette[subset]), 
                                        each = length(unique(merged_data$labels)))
            
            }
            else{stop('Some or all the names you entered for the subset param do not exist. 
                      Please make sure you are entering a vector of strings 
                      corresponding to the names of the reductions.')}
            
            if(plot_type == 'boxplot'){
              plot <- plot_boxplot_categorical(merged_data$silhouette_score,
                                               merged_data$method,
                                               names = c('silhouette score', 'method')) + 
              theme(axis.text.x = element_text(size = 10,angle = 45,hjust = 1),
                    legend.position = 'none')
            }
            
            if(plot_type == 'violin'){
              plot <- plot_violin(merged_data$silhouette_score, 
                                  merged_data$method, 
                                  names = c('silhouette score', 'method'), 
                                  overlay_type = 'boxplot') + 
                theme(axis.text.x = element_text(size = 10,angle = 45,hjust = 1),
                      legend.position = 'None')
            }
            return(plot)
          })

```

```{r}

rna_metrics <- new("BenchmarkMetrics",
                            Algorithm = character(0),  
                            Dataset = list(),   
                            Params = list(),          
                            RunningTime = numeric(0), 
                            Silhouette = list())

adt_metrics <- new("BenchmarkMetrics",
                            Algorithm = character(0),  
                            Dataset = list(),   
                            Params = list(),          
                            RunningTime = numeric(0), 
                            Silhouette = list())


rna_metrics <- ComputeMultipleSilhouette(bm_data, rna_metrics, 
                                         reductions = c('rna.umap',
                                                        'harmony_umap', 
                                                        'SCT_umap', 
                                                        'rpca_integrated_umap',
                                                        'cca_integrated_umap'),
                                         labels = 'celltype.l2')

adt_metrics <- ComputeMultipleSilhouette(umap_normalized_adt_all_methods, adt_metrics, labels = bm_data$celltype.l2)

rna_metrics@Silhouette$ruvIII_k2 <- compute_silhouette(rna_ruv_umap$layout, 
                                                       bm_data$celltype.l2, 
                                                       result_format = 'per_cluster')

adt_metrics@Silhouette$ruvIII_k1 <- compute_silhouette(adt_ruv_umap$layout, 
                                                       bm_data$celltype.l2, 
                                                       result_format = 'per_cluster')

```

```{r}
PlotMultipleSilhouette(adt_metrics)
```


```{r}
PlotMultipleSilhouette(rna_metrics)
```


```{r}

a <- list(Seurat_log_normalization = bm_data@reductions$pca@cell.embeddings[,1:10],
          Harmony = bm_data@reductions$harmony@cell.embeddings[,1:10],
          SCTrasform = bm_data@reductions$SCT_pca@cell.embeddings[,1:10],
          Seurat_rPCA = bm_data@reductions$rpca_integrated_pca@cell.embeddings[,1:10],
          Seurat_CCA = bm_data@reductions$cca_integrated_pca_scaled@cell.embeddings[,1:10],
          RUV_scaled = rna_ruv_pca_scaled$u[,1:10],
          RUV_unscaled  = rna_ruv_pca$u[,1:10])

rna_pca_metrics <- new("BenchmarkMetrics")

rna_pca_metrics <- ComputeMultipleSilhouette(a, rna_pca_metrics, labels = bm_data$celltype.l2)


```


```{r}

PlotMultipleSilhouette(rna_pca_metrics)

```


```{r, fig.width= 12}

# plot donor, libsize and celltype
a <- list()
a$u <- bm_data@reductions$pca@cell.embeddings[,1:10]
b <- list()
b$u <- bm_data@reductions$SCT_pca@cell.embeddings[,1:10]
c <- list()
c$u <- bm_data@reductions$harmony@cell.embeddings[,1:10]

p1 <- plot_linear_correlation(list(a,b, rna_ruv_pca, c), c('rna_raw_counts', 'SCT', 'ruv_k2', 'harmony'), bm_data$log2_libsize, 'libsize', is.pca.obj = T)
p2 <- plot_vector_correlation(list(a,b, rna_ruv_pca, c), c('rna_raw_counts', 'SCT', 'ruv_k2', 'harmony'), bm_data$donor, 'donor', is.pca.obj = T)
p3 <- plot_vector_correlation(list(a,b, rna_ruv_pca, c), c('rna_raw_counts', 'SCT', 'ruv_k2', 'harmony'), bm_data$celltype.l2, 'celltype', is.pca.obj = T)

gridExtra::grid.arrange(p1,p2,p3, nrow = 2, ncol=2)

```


```{r}
PlotMultipleSilhouette(adt_metrics)
```




# Cross study normalization

## Filtering genes from both studies
```{r}
bm_genes_to_keep <- edgeR::filterByExpr(as.matrix(bm_data@assays$RNA@layers$counts), group= bm_data$celltype.l2, min.count = 1, min.total.count = 20)

triana_genes_to_keep <- edgeR::filterByExpr(as.matrix(triana_2021@assays$RNA@counts), group= triana_2021$ct, min.count = 3.5, min.total.count = 20)

common_genes <- intersect(rownames(bm_data@assays$RNA)[bm_genes_to_keep] ,rownames(triana_2021@assays$RNA@counts)[triana_genes_to_keep])

```

## Do SCTransform first on both datasets before label transfer
```{r}

bm_data2 <- CreateSeuratObject(counts = bm_data1@assays$RNA@layers$counts[rownames(bm_data@assays$RNA) %in% common_genes,])
rownames(bm_data2) <- rownames(bm_data@assays$RNA)[rownames(bm_data@assays$RNA) %in% common_genes]
bm_data2 <- Seurat::SCTransform(bm_data2)
bm_data2 <- FindVariableFeatures(bm_data2)

triana_2021_2 <- CreateSeuratObject(counts = triana_2021@assays$RNA@counts[rownames(triana_2021@assays$RNA@counts) %in% common_genes,], 
                                    meta.data = triana_2021@meta.data)

triana_2021_2 <- Seurat::SCTransform(triana_2021_2)

```

## Label transfer
```{r}

# For L1 celltypes
anchors <- FindTransferAnchors(reference = bm_data2, 
                               normalization.method = 'SCT',
                               query = triana_2021_2, 
                               dims = 1:30)

predicted_celltypes <- TransferData(anchorset = anchors, refdata = bm_data$celltype.l1, dims = 1:30)
triana_2021_2@meta.data$celltype.l1_with_transfer <- predicted_celltypes$predicted.id


# For l2 celltypes
predicted_celltypes2 <- TransferData(anchorset = anchors, refdata = bm_data$celltype.l2, dims = 1:30)
triana_2021_2@meta.data$celltype.l2_with_transfer <- predicted_celltypes2$predicted.id


# Plot max prediction scores to see how confident the predictions are
hist(predicted_celltypes$prediction.score.max, main = 'Max predict. scores for l1 celltypes')
hist(predicted_celltypes2$prediction.score.max, main = 'Max predict. scores for l2 celltypes')

```

## Merge the two studies into one Seurat
```{r}

# Deal with metadata shenanigans
bm_data2$study <- 'Stuart_2019'
triana_2021_2@assays$ADT@key <- 'adt_'
triana_2021_2$study <- 'Triana_2021'
bm_data2$supplied_celltype_l2 <- as.vector(bm_data$celltype.l2)
triana_2021_2$supplied_celltype_l2 <- as.vector(triana_2021$ct)
bm_data2$celltype.l1_with_transfer <- as.vector(bm_data$celltype.l1)
bm_data2$celltype.l2_with_transfer <- as.vector(bm_data$celltype.l2)

# merge 
merged_data <- merge(bm_data2, triana_2021_2)

```

## Run the basic seurat pipeline for dim reduction (like we did before)
```{r}
DefaultAssay(merged_data) <- 'RNA'
merged_data <- NormalizeData(merged_data) %>% FindVariableFeatures() %>% ScaleData() %>% RunPCA(reduction.name = 'rna_pca')

# Seurat's new umap doesnt work for merged data, so we need to do it ourselves.
# merged_data <- RunUMAP(merged_data, reduction = 'rna_pca', dims = 1:30, reduction.name = 'rna_umap')
# This will error 'no slot of name "i" for this object of class "dgRMatrix"'

rna_umap <- umap(merged_data[['rna_pca']]@cell.embeddings[,1:30])
rna_umap_dim_reduc <- SeuratObject::CreateDimReducObject(embeddings = rna_umap$layout, key = 'rna_')
merged_data@reductions$rna_umap <- rna_umap_dim_reduc

```

```{r}
# This is seurat log normalized scaled & var features only.

p1 <- DimPlot(merged_data, reduction = 'rna_umap', group.by = 'study', label = T, repel = T) +
  NoLegend()
p2 <- DimPlot(merged_data, reduction = 'rna_umap', group.by = 'celltype.l1_with_transfer', label = T, repel = T) + 
  NoLegend()

p1 + p2

```

# harmony
```{r}
a1 <- Sys.time()
merged_data <- harmony::RunHarmony(merged_data, reduction.use = 'rna_pca', group.by.vars = 'study')
a2 <- Sys.time()
harmony_runtime <- a2-a1

merged_data <- Seurat::RunUMAP(merged_data, reduction = 'harmony', dims = 1:30, reduction.name = 'harmony_umap')
harmony_umap <- umap(merged_data[['harmony']]@cell.embeddings[,1:30])

merged_data[['harmony_umap']] <- CreateDimReducObject(embeddings = harmony_umap$layout, key = 'harmony_')


```

```{r}
p1 <- DimPlot(merged_data, reduction = 'harmony_umap', group.by = 'study', label = T, repel = T) +
  NoLegend()
p2 <- DimPlot(merged_data, reduction = 'harmony_umap', group.by = 'celltype.l1_with_transfer', label = T, repel = T) + 
  NoLegend()

p1 + p2

```
# fastMNN

```{r}

merged_counts <- cbind(merged_data@assays$RNA@layers$counts.1, merged_data@assays$RNA@layers$counts.2)

a1 <- Sys.time()
merged_fastMNN <- batchelor::fastMNN(as.matrix(merged_counts),
                                 batch = merged_data$study,
                                 subset.row = as.vector(merged_data@assays$RNA@features[,5]))
a2 <- Sys.time()
mnn_runtime <- a2-a1
```

```{r}
merged_fastMNN_pcs <- merged_fastMNN@int_colData$reducedDims$corrected
rownames(merged_fastMNN_pcs) <- colnames(merged_data)

# fastMNN_umap <- RunUMAP(bm_data, dims = 1:30, reduction = 'fastMNN', reduction.name = 'fastMNN_umap')
merged_data[['fastMNN_umap']] <- CreateDimReducObject(embeddings = umap(merged_fastMNN_pcs[,1:30])$layout, key = 'mnn_')

```

```{r}
p1 <- DimPlot(merged_data, reduction = 'fastMNN_umap', group.by = 'study', label = T, repel = T) +
  NoLegend()
p2 <- DimPlot(merged_data, reduction = 'fastMNN_umap', group.by = 'celltype.l1_with_transfer', label = T, repel = T) + 
  NoLegend()

p1 + p2

```

# ruvIII

```{r}

# NOT ROBUST TO LOWLY EXPRESSED GENES
# try doing intersection instead of ranking
# for biology, calculate the corr within batch not globally (try for libsize as well)

setGeneric(name = 'find_corr',
           function(data, variable_vector){standardGeneric('find_corr')})

setMethod('find_corr',
          signature = c(variable_vector = 'numeric'),
          function(data, variable_vector){
            results <- Rfast::correls(y=variable_vector, x=t(data), type = 'spearman') %>% as.data.frame()
            return(as.vector(results$correlation))
          })

setMethod('find_corr',
          signature = c(variable_vector = 'character'),
          function(data, variable_vector){
            #results <- ftest(data, variable_vector)
            results <- parallel::mclapply(1:nrow(data),
                                          function(x){summary(aov(as.vector(data[x,])~variable_vector))[[1]][4][1,1]})
            return((unlist(results)))
          })


setGeneric(name = 'FindNCG',
           function(object,
                    unwanted_variables,
                    bio_variables,
                    no.ncg = 1000,
                    apply_log = T,
                    sample_fraction = 0.1)
             {standardGeneric('FindNCG')})


setMethod('FindNCG', 
          signature = c(object = 'Seurat',
                        unwanted_variables = 'character',
                        bio_variables = 'character'),
          function(object,
                   unwanted_variables,
                   bio_variables,
                   no.ncg,
                   apply_log,
                   sample_fraction){
            
            sample_num <- sample_fraction * ncol(object)
            sample_ <- sample(ncol(object), sample_num)
            message(paste0('Sampling ', sample_num,' cells from your data'))
            
            # Hardcoding main data matrix to assays > RNA > layers > counts
            if(apply_log){data <- log2(object@assays$RNA@layers$counts+1)}
            else{data <- object@assays$RNA@layers$counts}
            
            data <- data[,sample_] %>% as.matrix()
            metadata <- object@meta.data[sample_,]
            
            message('Calculating Spearman correlation for continuous variables & F score for categorical variables')
            corr_data <- parallel::mclapply(c(unwanted_variables, bio_variables), 
                                          function(x){find_corr(data, metadata[[x]])})
            
            names(corr_data) <- c(unwanted_variables, bio_variables)
            
            # Flip bio variables 
            message('Finding genes highly affected by unwanted variables but not affected by biological variables')
            for(name in names(corr_data)){
              if(name %in% bio_variables){
                corr_data[[name]] <- corr_data[[name]] * (-1)
              }
            }
            corr_data <- do.call(cbind, corr_data) %>% as.data.frame()
            rownames(corr_data) <- rownames(object[['RNA']])
            ranks <- apply(corr_data, 2, rank) %>% as.data.frame()
            ranks$avg_expr <- rowMeans2(data)
            prod_ranks <- apply(ranks, 1, prod)
            final_gene_ranks <- prod_ranks[base::order(-prod_ranks)]
            message('FindNCG Completed!')
            
            return(names(final_gene_ranks)[1:no.ncg])
            
          })

```


```{r}

merged_data$log2_libsize <- log2(colSums2(merged_counts))
merged_counts_seurat <- CreateSeuratObject(counts = merged_counts, assay = 'RNA')
merged_counts_seurat@meta.data <- merged_data@meta.data[,c('study', 'log2_libsize', 'celltype.l1_with_transfer')]
rownames(merged_counts_seurat@assays$RNA) <- rownames(merged_data@assays$RNA)

merged_control_genes <- FindNCG(merged_counts_seurat, 
                                unwanted_variables = c('study', 'log2_libsize'),
                                bio_variables = c('celltype.l1_with_transfer'),
                                apply_log =  T,
                                sample_fraction = 0.1)

ncg_pca <- run_PCA(merged_counts[which(rownames(merged_counts_seurat@assays$RNA) %in% merged_control_genes),], 30)

ncg_umap <- umap((ncg_pca$u))

plot_UMAP(ncg_umap$layout, run_umap = F, metadata_vector = merged_data$study, title = 'control genes')+
  coord_cartesian(ylim = c(-7,7))

```


```{r, fig.width= 10}
plot_UMAP(ncg_umap$layout, run_umap = F, metadata_vector = merged_data$celltype.l1_with_transfer, 
          title = 'control genes')+
  coord_cartesian(ylim = c(-10,10))

```

# RUV

```{r}
merged_counts_seurat@assays$RNA@layers$counts <- merged_counts_seurat@assays$RNA@layers$counts %>% as.matrix() %>% as.sparse()
DefaultAssay(merged_counts_seurat) <- 'RNA'
colnames(merged_counts_seurat@assays$RNA@layers$counts) <- colnames(merged_data@assays$RNA)

M <- ruv::replicate.matrix(merged_counts_seurat$celltype.l1_with_transfer)
Y <- as.matrix(t(log2(merged_counts_seurat@assays$RNA@layers$counts+1)))

a1 <- Sys.time()
merged_ruviii_rna <- RUV_III(Y = Y,
                      Yrep = Y,
                      M = M,
                      ctl = rownames(merged_counts_seurat) %in% merged_control_genes,
                      k = 20,
                      return.info = T)
a2 <- Sys.time()
ruv_runtime <- a2-a1
merged_ruviii_rna$newY[merged_ruviii_rna$newY < 0] <- 0
merged_ruviii_rna$newY <- round(merged_ruviii_rna$newY, digits = 2)
merged_ruviii_rna$newY <- as.sparse(merged_ruviii_rna$newY)

```

# fixing my umap function

```{r}

plot_UMAP <- function(matrix, metadata_vector, title = 'UMAP', aspect_ratio = 1/1, run_umap = T, label_is_continuous = F, 
                      continuous_var_upper_lim = NULL, alpha = 1){
  # taking a matrix and a vector of metadata, plot UMAP of the matrix colored by the groups in the metadata vector
  
  if(run_umap){
    umap_result = umap(t(matrix))
    df = data.frame(umap_result$layout)}
  if(!run_umap){df <- as.data.frame(matrix)}
  colnames(df) = c("UMAP1", "UMAP2")
  
  if(!is.null(continuous_var_upper_lim)){
    if(class(continuous_var_upper_lim) != 'numeric'){stop("You didn't enter a numerical value for the continous variable uppe limit. Please only enter numbers.")}
    else(metadata_vector <- lapply(metadata_vector,
                                   function(x) ifelse(x > continuous_var_upper_lim,
                                                      continuous_var_upper_lim,
                                                      x)) %>% unlist())}
  
  df$metadata = metadata_vector 
  
  if(!label_is_continuous){
    centroids <- aggregate(cbind(UMAP1, UMAP2) ~ metadata, df, mean)
    p <- ggplot(df, aes(x = UMAP1, y = UMAP2, color = metadata)) +
      geom_point(size = 0.07, alpha = alpha) +
      ggtitle(title) +
      theme_minimal() +
      theme(axis.line = element_line(colour = "grey50", linewidth = 0.9),
            panel.border = element_blank(),  #element_rect(colour = "grey90", fill=NA, size=0.7),
            panel.grid.major = element_blank(),  #element_line(color = "grey96"),
            panel.grid.minor = element_blank(),
            aspect.ratio = aspect_ratio,
            legend.position = "none")+
      geom_text(data = centroids, aes(label = metadata), size = 3, color = "black", hjust = 0.5, vjust = 0.5)
  }
  
  if(label_is_continuous){
    ggplot(df, aes(x = UMAP1, y = UMAP2, color = metadata)) +
      geom_point(size = 0.07, alpha = alpha) +
      scale_fill_viridis() +
      scale_color_viridis() +
      ggtitle(title) +
      theme_minimal() +
      theme(axis.line = element_line(colour = "grey50", linewidth = 0.9),
            panel.border = element_rect(colour = "grey90", fill=NA, size=0.7),
            panel.grid.major = element_line(color = "grey96"),
            aspect.ratio = 1/1.05)  
    }
  
  if(!label_is_continuous){
  xdens <- axis_canvas(p, axis = "x")+
    geom_density(df, mapping = aes(x = UMAP1, fill = metadata_vector), color= 'grey55', alpha = 0.50, size = 0.2) +
    theme(legend.position = "none")
  
  ydens <- axis_canvas(p, axis = "y", coord_flip = TRUE) +
    geom_density(df, mapping = aes(x = UMAP2, fill = metadata_vector), color= 'grey55', alpha = 0.50, size = 0.2) +
    theme(legend.position = "none")+
    coord_flip()
  }
  
  p1 <- insert_xaxis_grob(p, xdens, grid::unit(.2, "null"), position = "top")
  p2 <- insert_yaxis_grob(p1, ydens, grid::unit(.2, "null"), position = "right")
  pList <- ggdraw(p2)
  
  return(pList)
}



```


```{r}
plot_UMAP(merged_data@reductions$harmony_umap@cell.embeddings, merged_data$celltype.l2_with_transfer, run_umap = F, alpha = 0.1)

```



```{r}
merged_rna_ruv_pca <- run_PCA(t(scale(merged_ruviii_rna$newY[,as.vector(merged_data@assays$RNA@features[,5])])), 30)
merged_rna_ruv_umap <- umap(merged_rna_ruv_pca$u)

plot_UMAP(merged_rna_ruv_umap$layout, merged_data$celltype.l2_with_transfer, run_umap = F)

```

```{r}

plot_UMAP(merged_rna_ruv_umap$layout, merged_data$study, run_umap = F)

```


```{r}
a1 <- Sys.time()
merged_ruviii_rna <- RUV_III(Y = Y,
                      Yrep = Y,
                      M = M,
                      ctl = rownames(merged_counts_seurat) %in% merged_control_genes,
                      k = 4,
                      return.info = T)
a2 <- Sys.time()
ruv_runtime <- a2-a1
merged_ruviii_rna$newY[merged_ruviii_rna$newY < 0] <- 0
merged_ruviii_rna$newY <- round(merged_ruviii_rna$newY, digits = 2)
merged_ruviii_rna$newY <- as.sparse(merged_ruviii_rna$newY)

```

```{r}
merged_rna_ruv_pca <- run_PCA(t(scale(merged_ruviii_rna$newY[,as.vector(merged_data@assays$RNA@features[,5])])), 30)
merged_rna_ruv_umap <- umap(merged_rna_ruv_pca$u)

plot_UMAP(merged_rna_ruv_umap$layout, merged_data$celltype.l1_with_transfer, run_umap = F)+
  coord_cartesian(xlim = c(-10,10), ylim = c(-10,10))

```



```{r, fig.width= 10}

plot_UMAP(merged_rna_ruv_umap$layout, merged_data$study, run_umap = F)

```





## Add ADT data
```{r}

# Subset to common adts and then concat the count matrix

common_adts <- intersect(sub("-AB$", "", rownames(triana_2021@assays$AB)), rownames(bm_data@assays$ADT))
triana_2021_2@assays$ADT <- CreateAssay5Object(counts = triana_2021@assays$AB@counts)
rownames(triana_2021_2@assays$ADT) <- sub("-AB$", "", rownames(triana_2021@assays$AB))

combined_matrix <- cbind(bm_data@assays$ADT@layers$counts[match(common_adts, rownames(bm_data@assays$ADT)),],
                         triana_2021_2@assays$ADT@layers$counts[match(common_adts, rownames(triana_2021_2@assays$ADT)),])

rownames(combined_matrix) <- common_adts
colnames(combined_matrix) <- colnames(merged_data)

combined_adt_assay <- CreateAssay5Object(counts = combined_matrix)
combined_adt_assay <- NormalizeData(combined_adt_assay, normalization.method = 'CLR', margin = 2)

merged_data[['ADT']] <- combined_adt_assay

```


## Run dim reduction and plot ADT
```{r}

DefaultAssay(merged_data) <- 'ADT'
merged_data <- ScaleData(merged_data) %>% RunPCA(reduction.name = 'adt_pca_scaled', npcs = 11)
scaled_adt_umap <- umap(merged_data@reductions$adt_pca_scaled@cell.embeddings)

adt_pca_unscaled <- run_PCA(merged_data@assays$ADT@layers$data, pcs = 11)
unscaled_adt_umap <- umap(adt_pca_unscaled$u)


adt_raw_counts_pca_scaled <- run_PCA(t(scale(t(merged_data@assays$ADT@layers$counts))), pcs = 11)
unscaled_adt_raw_counts_umap <- umap(adt_raw_counts_pca_scaled$u)

```


```{r, fig.width= 8}
p1 <- plot_UMAP(unscaled_adt_raw_counts_umap$layout, run_umap = F, metadata_vector = merged_data$celltype.l2_with_transfer, 
          title = 'Raw counts (scaled) vs celltype ', alpha = 0.2)

p2 <- plot_UMAP(unscaled_adt_raw_counts_umap$layout, run_umap = F, metadata_vector = merged_data$study, 
          title = 'vs study', alpha = 0.2)

gridExtra::grid.arrange(p1,p2, ncol=2)

```

```{r, fig.width= 8}
p1 <- plot_UMAP(scaled_adt_umap$layout, run_umap = F, metadata_vector = merged_data$celltype.l1_with_transfer, 
          title = 'CLR (scaled) vs celltype ', alpha = 0.2)

p2 <- plot_UMAP(scaled_adt_umap$layout, run_umap = F, metadata_vector = merged_data$study, 
          title = 'vs study', alpha = 0.2)

gridExtra::grid.arrange(p1,p2, ncol=2)

```
#dsb

```{r}

merged_adt_dsb <- dsb::ModelNegativeADTnorm(t(merged_data@assays$ADT@layers$counts), use.isotype.control = F)
merged_adt_dsb_pca_unscaled <- run_PCA(t(merged_adt_dsb), pcs = 11)
merged_adt_dsb_pca_scaled <- run_PCA(t(scale(merged_adt_dsb)), pcs = 11)

merged_adt_dsb_umap <- umap(merged_adt_dsb_pca_scaled$u)

```


```{r, fig.width= 8}
p1 <- plot_UMAP(merged_adt_dsb_umap$layout, run_umap = F, metadata_vector = merged_data$celltype.l1_with_transfer, 
          title = 'DSB (scaled) vs celltype ', alpha = 0.2)

p2 <- plot_UMAP(merged_adt_dsb_umap$layout, run_umap = F, metadata_vector = merged_data$study, 
          title = 'vs study', alpha = 0.2)

gridExtra::grid.arrange(p1,p2, ncol=2)

```

```{r}

merged_adtnorm <- ADTnorm(as.matrix(t(combined_matrix)), data.frame(sample = merged_data$study), save_outpath = '/vast/scratch/users/liu.ne/')
#adt_adtnorm <- t(adt_adtnorm)
merged_adtnorm_pca_unscaled <- run_PCA(t(merged_adtnorm), pcs = 11)
merged_adtnorm_pca_scaled <- run_PCA(t(scale(merged_adtnorm)), pcs = 11)

merged_adt_adtnorm_umap <- umap(merged_adtnorm_pca_scaled$u)

```

```{r, fig.width= 8}
p1 <- plot_UMAP(merged_adt_adtnorm_umap$layout, run_umap = F, metadata_vector = merged_data$celltype.l1_with_transfer, 
          title = 'ADTnorm (scaled) vs celltype ', alpha = 0.2)

p2 <- plot_UMAP(merged_adt_adtnorm_umap$layout, run_umap = F, metadata_vector = merged_data$study, 
          title = 'vs study', alpha = 0.2)

gridExtra::grid.arrange(p1,p2, ncol=2)

```

# RUVIII

```{r}
DefaultAssay(merged_data) <- 'ADT'
merged_data$log2_adt_libsize <- log2(colsums(as.matrix(merged_data@assays$ADT@layers$counts)))

# THIS WILL ERROR 
merged_adt_prpc <- sc_PRPC_v2(merged_data,
                           batch = 'study',
                           libSize = 'log2_adt_libsize',
                           npcs = 11,
                           libSize.prps = T,
                           batch.prps = T)


 merged_adt_ruv <- RUV_III(Y= as.matrix(t(log2(combined_matrix+1))), 
                          Yrep = as.matrix(t(log2(combined_matrix+1))),
                          ctl = rownames(combined_matrix) %in% rownames(combined_matrix),
                          M = ruv::replicate.matrix(merged_data$celltype.l2_with_transfer),
                          k = 10)

merged_adt_ruv_pca_unscaled <- run_PCA(t(merged_adt_ruv), pcs = 11)
merged_adt_ruv_pca_scaled <- run_PCA(t(scale(merged_adt_ruv)), pcs = 11)

merged_adt_ruv_umap <- umap(merged_adt_ruv_pca_scaled$u)

```

```{r, fig.width= 8}
p1 <- plot_UMAP(merged_adt_ruv_umap$layout, run_umap = F, metadata_vector = merged_data$celltype.l1_with_transfer, 
          title = 'ADTnorm (scaled) vs celltype ', alpha = 0.2)

p2 <- plot_UMAP(merged_adt_ruv_umap$layout, run_umap = F, metadata_vector = merged_data$study, 
          title = 'vs study', alpha = 0.2)

gridExtra::grid.arrange(p1,p2, ncol=2)

```



```{r}



```






```{r}
# Backup data
# save.image(file= '/vast/scratch/users/liu.ne/bm_CITEseq_backup.RData')
# load('/vast/scratch/users/liu.ne/bm_CITEseq_backup.RData')

```











